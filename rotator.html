<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css?family=Victor Mono|Audiowide|Bebas Neue"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@100..900&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Syne+Mono&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <title>Rotator Controller</title>
    <style>
      body,
      html {
        height: 100%;
        margin: 0;
      }
      #map {
        width: 100%;
        height: 100%;
      }
      .azi-muth {
        font-family: "Syne Mono", sans-serif;
        font-size: 2vw;
        padding-top: 10px;
        position: absolute;
        bottom: 0;
        left: 0;
        z-index: 9999;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div class="azi-muth" id="azimuth">Bearing unreacheable</div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-rotatedmarker/leaflet.rotatedMarker.js"></script>
    <script>
      // Force your Latitude and Longitude with the values below
      //
      // const myQTH = { lat: 40.12345, lng: -100.12345 };
      //
      // Define the rotator port for Hamlib (rotctld)
      const port = "4535";
      //
      var hdg = 0;

      function rot(heading) {
        url = "http://localhost:8073/rotctl/P?" + heading + " 0&__port=" + port;
        // Make the POST request using the Fetch API
        fetch(url, { mode: "no-cors" })
          .then((result) => {
            console.log("POST request successful:", result);
            // Handle the response data here
          })
          .catch((error) => {
            console.error("Error:", error);
            // Handle any errors here
          });
      }

      function get_rot() {
        url = "http://localhost:8073/rotctl/p?&__port=" + port;
        // Make the POST request using the Fetch API
        fetch(url)
          .then((response) => response.text())
          .then((data) => {
            data = JSON.parse(data);
            az = data.azimuth.split(".");
            document.getElementById("azimuth").innerHTML =
              "Bearing " + az[0] + "&deg;";
            userMarker.bindPopup("Az " + az[0] + "&deg;");
          });
      }

      getRotId = setInterval(() => get_rot(), 1500);

      // Initialize the map
      var map = L.map("map").setView([0, 0], 5);

      // Add OpenStreetMap tiles
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
      }).addTo(map);

      // Define user's location and marker
      var userLocation;
      var userMarker = L.marker([0, 0]).addTo(map);
      if (typeof myQTH !== "undefined") {
        userLocation = myQTH;
        map.setView(userLocation, 5);
        userMarker
          .setLatLng(userLocation)
          .bindPopup("You are here")
          .openPopup();
        console.log("Forced location: ", myQTH);
      } else {
        // Get the user's location and initial zoom level Range is 1 to 13 - Ideal is 5
        map.locate({ setView: true, maxZoom: 5 });
        // Handle location found
        map.on("locationfound", function (e) {
          userLocation = e.latlng;
          userMarker
            .setLatLng(userLocation)
            .bindPopup("You are here")
            .openPopup();
          console.log("Detected location: ", e.latlng);
        });
      }

      // Initialize the line and arrow marker
      var line;
      var circleMarker;

      // Handle click event on the map
      map.on("click", function (e) {
        if (!userLocation) {
          alert("Location missing...");
          return;
        }

        var clickLocation = e.latlng;
        var bearing = calculateBearing(
          userLocation.lat,
          userLocation.lng,
          clickLocation.lat,
          clickLocation.lng
        );
        var distance = calculateDistance(
          userLocation.lat,
          userLocation.lng,
          clickLocation.lat,
          clickLocation.lng
        );

        // Remove the previous line if it exists
        if (line) {
          map.removeLayer(line);
        }
        if (circleMarker) {
          map.removeLayer(circleMarker);
        }
        // Draw a line from user location to the clicked point
        line = L.polyline([userLocation, clickLocation], {
          color: "blue",
        }).addTo(map);

        // Add a circle marker at the clicked point
        circleMarker = L.circleMarker(clickLocation, {
          radius: 8,
          color: "red",
        }).addTo(map);

        // Display bearing and distance information
        circleMarker
          .bindPopup(
            "Bearing: " +
              bearing.toFixed(2) +
              " degrees<br>Distance: " +
              distance.toFixed(2) +
              " km<br>Latitude: " +
              rtrim(clickLocation.lat, 8) +
              "<br>Longitude: " +
              rtrim(clickLocation.lng, 9)
          )
          .openPopup();

        hdg = bearing.toFixed(2);
        circleMarker.addEventListener("click", _markerOnClick);
      });

      var _markerOnClick = function (e) {
        rot(hdg);
        console.log("Selected: ", hdg);
      };

      function rtrim(text, chars) {
        return text.toString().substr(0, chars);
      }

      // Function to calculate bearing between two points
      function calculateBearing(lat1, lon1, lat2, lon2) {
        var rad = Math.PI / 180;
        var dLon = (lon2 - lon1) * rad;
        var y = Math.sin(dLon) * Math.cos(lat2 * rad);
        var x =
          Math.cos(lat1 * rad) * Math.sin(lat2 * rad) -
          Math.sin(lat1 * rad) * Math.cos(lat2 * rad) * Math.cos(dLon);
        var bearing = Math.atan2(y, x) * (180 / Math.PI);
        return (bearing + 360) % 360;
      }

      // Function to calculate distance between two points using the Haversine formula
      function calculateDistance(lat1, lon1, lat2, lon2) {
        var R = 6371; // Radius of the Earth in kilometers
        var dLat = (lat2 - lat1) * (Math.PI / 180);
        var dLon = (lon2 - lon1) * (Math.PI / 180);
        var a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * (Math.PI / 180)) *
            Math.cos(lat2 * (Math.PI / 180)) *
            Math.sin(dLon / 2) *
            Math.sin(dLon / 2);
        var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        var distance = R * c;
        return distance;
      }
    </script>
  </body>
</html>
